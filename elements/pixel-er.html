<link rel="import" href="../bower_components/polymer/polymer.html">

<dom-module id="pixel-er">
  <template strip-whitespace>
    <style>
      :host {
        display: block;
      }

      :host ::content .output {
        margin: 20px auto;
        word-wrap: break-word;
      }
    </style>

    <canvas id="canvas" width="400" height="400" hidden></canvas>
    <img id="image" on-load="_onImageLoaded" hidden>
    <content id="content" select=".output"></content>

    <canvas id="palette" height="22" width="22" hidden>
  </template>

  <script>
    var canvasWidth = 600;

    Polymer({
      is: 'pixel-er',

      properties: {
        file: {
          type: Object,
          observer: '_fileChanged'
        },

        resolution: {
          type: Number,
          value: 60
        }
      },

      attached: function() {
        this._ctx = this.$.canvas.getContext('2d');

        // From https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled
        this._ctx.mozImageSmoothingEnabled = false;
        this._ctx.msImageSmoothingEnabled = false;
        this._ctx.imageSmoothingEnabled = false;

        this.$.canvas.width = canvasWidth;

        this._initEmojiMap();
      },

      _fileChanged: function(file) {
        if (!this._reader) {
          this._reader = new FileReader();
          this._reader.onload = this._loadFile.bind(this);
        }
        this._reader.readAsDataURL(file);
      },

      _loadFile: function(event) {
        this.$.image.src = event.target.result;
        //filename.innerHTML = e.target.files[0].name;
      },

      _initEmojiMap: function() {
        // From http://www.unicode.org/Public/UNIDATA/EmojiSources.txt
        // Took out 2002/2003/2005 because they didn't look printable.
        this._palette = ['â”','ğŸ‘ˆ','ğŸ‘’','ğŸ‘£','âœ³','ğŸ•','âš ','â¬œ','ğŸ“¶','ğŸ¥','ğŸ—¼','ğŸ’ª','ğŸ‘‹','ğŸ•–','â°','ğŸŒ¸','â™‘','ğŸ ','ğŸ”¶','ğŸˆ','ğŸ˜¹','ğŸ‘€','ğŸ™','ğŸ·','ğŸ”˜','ğŸ','ğŸš¾','ğŸ”ƒ','ğŸµ','ğŸ—¾','ğŸ£','ğŸ’¾','ğŸ‘’','ğŸŒ•','ğŸ½','ğŸ’–','ğŸ’‡','ğŸ˜˜','ğŸ†š','ğŸš','ğŸˆš','ğŸŒ€','ğŸ’»','â‰','ğŸš“','âœ‹','ğŸ²','ğŸ“¥','ğŸ“®','ğŸ“¦','ğŸˆ','ğŸ»','â„¢','ğŸˆ¹','ğŸ‘¢','ğŸš','ğŸ’º','ğŸ‘¨','ğŸš€','ğŸ‘¨','ğŸ’—','ğŸ','ğŸ““','ğŸ‘¸','ğŸŠ','ğŸ’¤','â˜º','â›…','â“','ğŸ“','ğŸ‘§','â†–','ğŸˆš','ğŸŒŸ','ğŸ•','ğŸº','ğŸ”¦','ğŸ‘³','â¬†','ğŸ˜','ğŸ¬','ğŸ“ˆ','â”','ğŸ“‚','ğŸŒ','ğŸ‘œ','ğŸ','ğŸ”‘','ğŸ’´','ğŸ˜’','ğŸ‘ª','ğŸ ','â›º','ğŸ“©','ğŸ­','ğŸ“¼','ğŸ€','ğŸœ','â¤µ','ğŸ†’','â™¨','ğŸ˜¤','ğŸ”»','ğŸ™‡','ğŸ«','ğŸ','ğŸ“»','ğŸ´','ğŸ“¹','ğŸ®','ğŸ§','ğŸ’ ','ğŸˆ‚','â›º','ğŸ•™','ğŸ“±','ğŸ‘˜','ğŸ˜½','ğŸº','ğŸš«','ğŸ†˜','ğŸ•š','ğŸœ','â™','ğŸ ','â—','ğŸš½','â”','âš¡','ğŸ”—','ğŸ¥','ğŸ”','ğŸ“Ÿ','ğŸ‘¼','ğŸ‚','ğŸ’ª','ğŸ‘','ğŸ’«','â¡','ğŸ°','ğŸ’˜','ğŸ…','ğŸŒ•','ğŸš','â„','ğŸ‘Ÿ','ğŸ‘™','ğŸ’','ğŸ“¼','ğŸ‘¨','ğŸ”','ğŸ’¸','â†”','â™¦','ğŸ™','â™','âœ¨','ğŸ¸','ğŸ‘¹','ğŸ²','ğŸ”Œ','â™','ã€°','ğŸ±','ğŸŒŸ','ğŸ¦','ğŸ˜¢','ğŸ”®','ğŸŒ”','âœ’','ğŸ•','ğŸ ','ğŸ†‘','ğŸš§','ğŸ”¹','ğŸ‘¾','ğŸŒ€','ğŸª','ğŸ‘…','ğŸ˜„','ğŸš¥','ğŸ“®','ğŸŒ»','ğŸ»','â˜º','ğŸ“«','ğŸ‘«','â›ª','â–','ğŸ’','âœ’','ğŸ˜·','âœŒ','ğŸ§','ğŸ¸','â€¼','ğŸ™ˆ','ğŸ”Š','ğŸ”','ğŸ“¡','ğŸ›€','ğŸŒ¼','ğŸª','ğŸ“«','ğŸ˜°','â‰','ğŸŒ¿','ğŸ•”','â›','ğŸ”¹','ğŸš¾','ğŸ”¨','ğŸ‘','â¬','ğŸ‘¨','ğŸ¦','â™¨','âœ‰','ğŸ””','ğŸ»','ğŸŒ›','ğŸ“ˆ','ğŸš¨','ğŸ••','ğŸ˜·','ğŸ’º','ğŸŒ±','ğŸš¨','ğŸ“ƒ','ğŸŠ','â”','ğŸˆš','ğŸ¢','ğŸ˜ƒ','âœ–','ğŸ’š','ğŸ…¾','ğŸ˜”','ğŸ¤','ğŸ‘´','ğŸ‘º','ğŸ¿','ğŸ','ğŸ˜­','ğŸ³','â©','ğŸ”¤','âŒš','ğŸ¨','ğŸ’¼','ğŸ‘Œ','ğŸ“','ğŸ¶','ğŸŒ','ğŸ”ª','âœ','âŒ›','ğŸˆ´','ğŸ','ğŸ’œ','ğŸ’¼','ğŸ‘¼','ğŸ”²','ğŸ§','ğŸ™','ğŸ­','ğŸ‘±','ğŸ‘ª','ğŸ‘','ğŸ“”','ğŸ“›','ğŸš‰','ğŸ·','ğŸ’ ','ğŸ²','â€¼','ğŸŒ','ğŸˆ²','ğŸ’‚','â›µ','ğŸ”¼','ğŸš¹','ğŸ˜º','ğŸ“Ÿ','ğŸ‡','ğŸ“','ğŸˆ¯','ğŸƒ','ğŸ™','ğŸ•–','ğŸš','ğŸŒ¾','ğŸº','ğŸ„','ğŸ¶','ğŸ¡','ğŸ‘º','ğŸ˜†','ğŸŒŸ','ğŸ˜¤','ğŸ†’','â›º','ğŸš','ğŸ“…','ğŸ¯','ğŸ˜','ğŸ”µ','ğŸ”¢','ğŸ“º','âš¾','ğŸ·','ğŸ³','â™‘','â–ª','ğŸ ','ğŸŒ‚','ğŸ','ğŸ’Œ','ğŸ˜¾','ğŸ˜¾','ğŸ‰','ğŸ¹','ğŸ˜¼','ğŸ”©','â‡','ğŸ†š','ğŸ©','ğŸ’¬','ğŸ­','ğŸœ','ğŸ›€','ã€½','ğŸµ','ğŸ„','ğŸš¨','ğŸ’«','ğŸ“','ğŸš½','ğŸ£','â—¼','ğŸ—','ğŸ•’','ğŸ“º','ğŸŒ¾','ğŸ™ˆ','ğŸ†š','ğŸ—¿','ğŸœ','ğŸ“£','ğŸ§','ğŸ…¾','ğŸ…','Â©','ğŸ’ˆ','ğŸ••','ğŸš','ğŸ§','ğŸ½','ğŸ“›','ğŸ”±','ãŠ™','ğŸ’','ğŸ’•','ğŸ˜¾','âœ’','â†—','ğŸ‘·','ğŸ’¯','ğŸ','ğŸ§','ğŸˆ·','ğŸ“‘','ğŸ…','ğŸ’®','â­•','ğŸ“ˆ','ğŸ‘','ğŸ™','ğŸ‘‚','ğŸ¨','ğŸ‘¾','ğŸ”','ğŸ‘’','ğŸŒ“','ğŸ˜¤','ğŸ’','âŒš','ğŸ‘±','ğŸ‘•','âœŠ','ğŸ”š','ğŸ¥','ğŸŒ‚','ğŸ·','ğŸ¹','ğŸ”¢','ğŸ’˜','ğŸˆš','ğŸ¡','ğŸ“¢','ğŸ“ƒ','ğŸŒ·','ğŸ™','ğŸ…°','ğŸ‘¤','â˜º','ğŸ¦','ğŸ‘ª','ğŸ“›','ğŸµ','âª','ğŸ…±','â‡','ğŸ˜œ','ğŸ˜','â‡','ğŸ’²','ğŸš','ğŸ‘†','â˜º','ğŸµ','ğŸ˜¢','ğŸ’¦','ğŸŒ±','ğŸ‘‘','ğŸ’£','ğŸˆ³','â¡','ğŸ”³','â†”','ğŸ§','ğŸ','ğŸ¶','ğŸ’¹','â†”','ğŸ“™','ğŸ','ğŸ¸','ğŸŠ','ğŸ”¤','ğŸ¡','âœ”','ğŸš','ğŸª','ğŸŒ™','ğŸ¤','ğŸ™Š','ğŸ¾','ğŸ‘Š','ğŸ‘œ','ğŸ˜±','ğŸš—','ğŸŒ°','ğŸ“˜','âœ‰','ğŸ‘¸','ğŸšŒ','ğŸ§','â›²','ğŸ“•','ğŸ¹','ğŸ”©','ğŸª','ğŸ®','ğŸˆ¶','ğŸ¥','ğŸ†','ğŸ”','ğŸ™','ğŸ”','ğŸ','ğŸƒ','ğŸ˜†','ğŸ†–','ğŸ“œ','ğŸˆ¹','ğŸ˜','ğŸ˜’','â™Š','ğŸ˜¡','ğŸ¡','ğŸ˜¥','ğŸ”','ğŸ±','ğŸ”¤','â™£','ğŸ‘”','ğŸ²','ğŸ‘‚','ğŸ”£','ğŸ‰‘','ğŸ“¤','ğŸ†','â†”','ğŸ˜²','ğŸ‚','ğŸ','ğŸ”´','ğŸ¥','â­','â­•','ğŸ“š','ğŸŒ„','ğŸŒ¿','ğŸ•—','â›³','ğŸ“‡','â™ ','ğŸ”','ğŸ“œ','ğŸª','ğŸ”«','ğŸ¹','ğŸ˜','â','ğŸ‘‚','ğŸ’','ğŸ•“','ğŸ’ƒ','ğŸ“ƒ','ğŸ¦','ğŸ‘”','ğŸ‘´','ğŸ’‘','ğŸ†”','â˜º','ğŸ’–','ğŸ•—','âœŒ','ğŸŒ“','â†•','ğŸˆ²','ğŸ’“','â¬†','â”','ğŸš¬','â¤','ğŸ‘²','ğŸ“','ğŸš½','ğŸ£','ğŸ’•','ğŸ‘º','ğŸ’¨','ğŸ¦','ğŸ¥','ğŸ†—','â„¹','ğŸ˜»','ğŸ”·','ğŸ“¹','ğŸ‘—','ğŸ˜Œ','ğŸ‰','ğŸ”','ğŸ“‰','ğŸˆº','ğŸ”','â†–','ğŸ“•','ğŸŒ‡','ğŸ“¹','ğŸŒ”','â˜€','â›³','â†–','ğŸ´','ğŸ¾','â—€','âš¡','ğŸƒ','â†˜','â›ª','ãŠ—','ğŸ’‚','ğŸ™Š','ğŸ”£','ğŸ˜–','ğŸ˜·','âœ’','ğŸ’±','ğŸ','â˜”','ğŸ¥','ğŸ”’','â›…','ğŸš½','ğŸ’','ğŸ“¹','ğŸ»','ğŸ“«','ğŸ˜–','ğŸº','ğŸ’ª','ğŸ¿','ğŸ˜','â–','ğŸ•–','ğŸ‘ˆ','ğŸ˜‹','ğŸ¢','ğŸ¢','ğŸ“Œ','ğŸ‘‘','â†˜','ğŸ°','ğŸšš','ğŸ’‚','â˜‘','âœ–','ğŸ’š','ğŸ‚','ğŸµ','ğŸ˜‹','ğŸ”¢','ğŸ“£','â€¼','ğŸ“¦','ğŸ˜­','ğŸ ','ğŸ´','â†—','âœ–','â˜€','ğŸ‰','ğŸ”›','ğŸŒ‡','ğŸ','â™Š','ğŸ†','ğŸ’','ğŸ‘¤','ğŸ’²','â³','ğŸ·','ğŸ”¹','ğŸš‰','ğŸ˜“','ğŸŠ','ğŸ‰','ğŸ“§','ğŸ”Œ','ğŸŠ','ğŸ‚','ğŸ¦','ğŸŒ“','ğŸ“ ','ğŸª','ğŸ˜¾','ğŸ‘·','ğŸˆ¶','ğŸƒ','â–¶','ğŸ¹','ğŸº','ğŸ˜­','ğŸ’§','ğŸ¨','â­•','â¤´','ğŸ’Ÿ','ğŸŒ‰','ğŸ¢','ğŸ“‚','â•','ğŸ’','ğŸ’€','ğŸ™Œ','â™¨','â†™','ğŸ“‘','ğŸ³','ğŸ’£','ğŸ”¡','âœ”','ğŸ“–','ğŸ¼','â¬','ğŸ‘¿','ğŸ“‚','ğŸ”','ğŸ’ˆ','ğŸ²','ğŸš¾','ğŸ','ğŸ¥','ãŠ—','ğŸ’‡','â¬œ','ğŸ›€','ğŸ’±','ğŸ€','â˜','ğŸ¹','ğŸ’³','ğŸ“„','ğŸ¦','ğŸŒ¹'];
        this._emojiColorMap = {};

        var ctx = this.$.palette.getContext('2d');
        ctx.font = '20px sans-serif';

        // For each emoji in the palette, paint it to the canvas and
        // then calculate its average colour.
        for (var i = 0; i < this._palette.length; i++) {
          // Paint it.
          ctx.clearRect(0, 0, 22, 22);
          ctx.fillText(this._palette[i], 0, 20);
          var rgb = this._getAverageColor(ctx.getImageData(0, 0, 22, 22));

          // Bam.
          this._emojiColorMap[rgb.r + ',' + rgb.g  + ',' + rgb.b] = this._palette[i];
        }

        console.log(this._emojiColorMap);
      },

      _onImageLoaded: function(event) {
        var imageRatio = this.$.image.height / this.$.image.width;

        var pixelsPerWidth = this.resolution;
        var pixelsPerHeight = Math.floor(pixelsPerWidth * imageRatio);

        // Adjust the canvas to fit the shape of the image.
        this.$.canvas.height = Math.ceil(canvasWidth * imageRatio);

        this._displayPixelatedImage(pixelsPerWidth, pixelsPerHeight);
      },

      _displayPixelatedImage: function(pixelsPerWidth, pixelsPerHeight) {
        // Oopsies?
        if (!this.$.canvas.width || !this.$.canvas.height) {
          return;
        }

        var imageData = this._getPixellatedImageData(pixelsPerWidth, pixelsPerHeight);
        var colors = this._getPixelColors(this.$.canvas, imageData, pixelsPerWidth, pixelsPerHeight);

        // I don't love this.
        var container = Polymer.dom(this.$.content).getDistributedNodes()[0];

        // Remove the previous render and redisplay the new image.
        container.innerHTML = '';
        container.style.width = this.$.canvas.width +'px';
        container.style.height = this.$.canvas.height +'px';

        var fragment = document.createDocumentFragment();

        var pixelWidth = this.$.canvas.width / pixelsPerWidth;
        var pixelHeight = this.$.canvas.height / pixelsPerHeight

        for (var i = 0; i < colors.length; i++) {
          var pixel = this._drawPixel(colors[i], pixelWidth, pixelHeight);

          fragment.appendChild(pixel);

          // Add a <br> at the end of every row so that we can copy paste this
          // as a grid.
          if (i % pixelsPerWidth === (pixelsPerWidth - 1)) {
            fragment.appendChild(document.createElement('br'));
          }
        }
        container.appendChild(fragment);
      },

      _getPixellatedImageData: function(pixelsPerWidth, pixelsPerHeight) {
        // Draw the image super tiny and then scale it from the tiny size
        // to the actual canvas size, which pixellates it.
        this._ctx.drawImage(this.$.image, 0, 0, pixelsPerWidth, pixelsPerHeight);
        this._ctx.drawImage(this.$.canvas,
                     0, 0, pixelsPerWidth, pixelsPerHeight,          /* source */
                     0, 0, this.$.canvas.width, this.$.canvas.height /* dest */);

        return this._ctx.getImageData(0, 0, this.$.canvas.width, this.$.canvas.height);
      },

      _getPixelColors: function(canvas, imageData, pixelsPerWidth, pixelsPerHeight) {
        function getRGBA(data) {
          return 'rgba(' + data[0] + ',' + data[1] +
                  ',' + data[2] + ',' + data[3] + ')';
        }

        var colors = [];
        var widthRatio = canvas.width / pixelsPerWidth;
        var heightRatio = canvas.height / pixelsPerHeight;

        // How many original pixels we have in a "drawn" final pixel.
        for (var j = 0; j < pixelsPerHeight; j++) {
          for (var i = 0; i < pixelsPerWidth; i++) {
            var x = Math.round(widthRatio * i + 1) * 4;
            var y = Math.round(heightRatio * j + 1) * canvas.width * 4;

            var pixel = [imageData.data[y + x], imageData.data[y + x + 1], imageData.data[y + x + 2], imageData.data[y + x + 3]];
            var rgba = getRGBA(pixel);

            colors.push(rgba);
          }
        }
        return colors;
      },

      _drawPixel: function(rgba, size) {
        var pixel = document.createElement('span');
        pixel.className = 'pixel';
        pixel.style.display = 'inline-block';
        pixel.style.width = pixel.style.height = size + 'px';
        pixel.style.fontSize = size - 2 + 'px';
        pixel.style.backgroundColor = rgba;
        pixel.textContent = this._getClosestEmoji(rgba);
        return pixel;
      },

      _getClosestEmoji: function(rgba) {
        var split = rgba.replace('rgba(', '').replace(')', '').split(',');
        var minDistance = 10000000;
        var minColor = null;

        for (var color in this._emojiColorMap) {
          var rgb = color.split(',');

          var distance =
              3 * Math.abs(rgb[0] - split[0]) +
              4 * Math.abs(rgb[1] - split[1]) +
              3 * Math.abs(rgb[2] - split[2]);
          if (distance <= minDistance) {
            minDistance = distance;
            minColor = color;
          }
        }

        return this._emojiColorMap[minColor];
      },

      _getAverageColor: function(imageData) {
        var interval = 10;  // only look at every 10th pixel.
        var rgb = {r:0, g:0, b:0};
        var i = -4;
        var count = 0;

        while ( (i += interval * 4) < imageData.data.length ) {
          ++count;
          rgb.r += imageData.data[i];
          rgb.g += imageData.data[i+1];
          rgb.b += imageData.data[i+2];
        }

        // ~~ used to floor values
        rgb.r = ~~(rgb.r/count);
        rgb.g = ~~(rgb.g/count);
        rgb.b = ~~(rgb.b/count);

        return rgb;
      }

    });
  </script>
</dom-module>
